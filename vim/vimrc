" It is a text editor, not an IDE
" It probably has that feature built in
" Move with deliberate purpose
" The documentation is better than you imagine
" HJKL is not an important part of vim navigation
" Project drawers conflict with split windows, favor splits
" Visual clutter saps mental energy
" Use plugins sparingly
" Navigate by tags and search, not files
" If it feels hard, there is probably a better way
" You should understand every line in your vimrc
" UI "tabs" are probably not what you expect
" Don't seek mastery, seek proficiency

" Use spacebar as a leader key
let mapleader=" "

" Make Vim snappier
set updatetime=100

" Suppress the banner
let g:netrw_banner=0
" Open in prior window
let g:netrw_browse_split=4
" Change from left splitting to right splitting
let g:netrw_altv=1
" Tree style view in netrw
let g:netrw_liststyle=3

" Make Vim behave in a more useful way
set nocompatible

" Do not use a swapfile for the buffer
set noswapfile

" Automatically read file again if it was changed outside vim
set autoread

" Automatically save before :next, :make etc
set autowrite

" Set title of the window
set title

" Switch on syntax highlighting
syntax enable

filetype plugin indent on

if has('termguicolors')
	set termguicolors
	for s:cs in ['wildcharm', 'zaibatsu', 'habamax', 'default']
		try
			execute 'colorscheme ' . s:cs
			break
		catch /E185:/
			" colorscheme not found, try next
		endtry
	endfor
else
	colorscheme default
endif

" Show tabs, multiple consecutive spaces, trailing spaces and breaks
set list
if exists('+listchars')
	" Fall back to a simpler variant for older Vim versions
	set listchars=tab:»\ ,extends:›,precedes:‹,nbsp:␣,trail:·
	if has('patch-9.0.0000')
		set listchars+=lead:\ ,multispace:·
	endif
endif
let &showbreak = '↪ '

" Turn on line numbers
set number
" Turn on relative line numbers
set relativenumber
" Show the line and column number of the cursor position
set ruler

" Screen columns that are highlighted
set colorcolumn=80

" Enable case insensitive searching
set ignorecase
" All searches are case insensitive unless there's a capital letter
set smartcase
" Highlight search results
set hlsearch
" Enable incremental searching
set incsearch

" Enable text wrapping
set wrap
" Tabs=4spaces
set tabstop=4
set shiftwidth=4
" Do not expand tab
set noexpandtab

" Encoding set to UTF-8
set fileencoding=utf-8

" Number of items in popup menu
set pumheight=10

" Always show statusline
set laststatus=2

" Draw the signcolumn only when there is a sign to display
set signcolumn=auto

" Do smart autoindenting when starting a new line
set smartindent

" Splitting a window will put the new window below the current one
set splitbelow
" Splitting a window will put the new window right of the current one
set splitright

" If in Insert, Replace or Visual mode put a message on the last line
set showmode

" Delete comment character when joining commented lines.
set formatoptions+=j

" Minimal number of screen lines to keep above and below the cursor
set scrolloff=8
" Minimal number of screen columns to keep to the left and to the right of the
" cursor
set sidescrolloff=8

" Command-line completion operates in an enhanced mode
if has('wildmenu')
	set wildmenu
endif
if exists('+wildmode') && has('patch-9.1.0000')
	set wildmode=noselect:lastused,full
endif
if exists('+wildoptions') && has('patch-9.0.0000')
	set wildoptions=pum
endif
" Hide noise in completion
if has('wildignore')
	set wildignore+=*.pyc,*/.git/*,*/node_modules/*
endif

" Key mappings
" Search
nnoremap <leader>/ :grep<Space>
nnoremap N Nzz
nnoremap n nzz
" General navigation
nnoremap <Leader>b :buffer<Space>
nnoremap <C-S> :update<CR>
nnoremap <leader>f :find<Space>
nnoremap <leader>h :vert<Space>help<Space>
" Window navigation
nnoremap <C-D> <C-D>zz
nnoremap <C-H> <C-W>h
nnoremap <C-J> <C-W>j
nnoremap <C-K> <C-W>k
nnoremap <C-L> <C-W>l
nnoremap <C-U> <C-U>zz
nnoremap <Leader>w <C-W>
" Open in a split
nnoremap gsf <C-w>vgf
" Moving selected lines
nnoremap <A-Down> :m<Space>.+1<CR>==
nnoremap <A-Up> :m<Space>.-2<CR>==
xnoremap <A-Down> :m<Space>'>+1<CR>gv=gv
xnoremap <A-Up> :m<Space>'<-2<CR>gv=gv
" Quickfix list navigation
nnoremap <leader>cc :cclose<CR>
nnoremap <leader>co :copen<CR>
nnoremap [<C-Q> :cpfile<CR>zz
nnoremap [Q :crewind<CR>zz
nnoremap [q :cprevious<CR>zz
nnoremap ]<C-Q> :cnfile<CR>zz
nnoremap ]Q :clast<CR>zz
nnoremap ]q :cnext<CR>zz
" Location list navigation
nnoremap <leader>lc :lclose<CR>
nnoremap <leader>lo :lopen<CR>
nnoremap [<C-L> :lpfile<CR>zz
nnoremap [L :lrewind<CR>zz
nnoremap [l :lprevious<CR>zz
nnoremap ]<C-L> :lnfile<CR>zz
nnoremap ]L :llast<CR>zz
nnoremap ]l :lnext<CR>zz
" Argument list navigation
nnoremap [A :rewind<CR>
nnoremap [a :previous<CR>
nnoremap ]A :last<CR>
nnoremap ]a :next<CR>
" Tags navigation
nnoremap [t :tprevious<CR>zz
nnoremap ]t :tnext<CR>zz
nnoremap [T :trewind<CR>zz
nnoremap ]T :tlast<CR>zz
nnoremap [<C-T> :ptprevious<CR>zz
nnoremap ]<C-T> :ptnext<CR>zz
" Buffers navigation
nnoremap [B :brewind<CR>
nnoremap [b :bprevious<CR>
nnoremap ]B :blast<CR>
nnoremap ]b :bnext<CR>
" Clipboard
noremap <leader>y "+y
noremap <leader>p "+p
noremap <leader><s-p> "+<s-p>
" Make
nnoremap <Leader>m :make<Space>
" Open file in a vertical split
cnoremap <expr> <C-v> <SID>VertSplitFind()

" Use ripgrep for search if it's installed
if executable('rg')
	set grepprg=rg
				\\ --vimgrep
				\\ --smart-case
				\\ --follow
				\\ --hidden
				\\ --glob
				\\ '!.git/**'
endif

function! s:VertSplitFind() abort
	if getcmdtype() != ':'
		return "\<C-v>"
	endif
	let l:line = getcmdline()
	if l:line =~# '^\s*find\>'
		let l:new = substitute(l:line, '^\s*find\>', 'vert sfind', '')
		return "\<C-U>" . l:new . "\<CR>"
	endif
	if l:line =~# '^\s*buffer\>'
		let l:new = substitute(l:line, '^\s*buffer\>', 'vert sbuffer', '')
		return "\<C-U>" . l:new . "\<CR>"
	endif
	return "\<C-v>"
endfunction

" Initialise files cache.
let s:filescache = []

" Get a list of all files using built-in globpath.
function! s:GlobFiles() abort
	return globpath('.', '**', 1, 1)
			\->filter('!isdirectory(v:val)')
			\->map("fnamemodify(v:val, ':.')")
endfunction

" Get a list of all files using `fd` executable.
function! s:FdFiles() abort
	let l:find_command = 'fd
			\ --exclude .git
			\ --follow
			\ --full-path
			\ --hidden
			\ --type file'
	let l:result = systemlist(l:find_command)
	if v:shell_error
		echoerr l:result
		return []
	endif
	return l:result
endfunction

" Use GlobFiles as the default files_fetcher.
let s:files_fetcher = function('s:GlobFiles')

" Use fd to find files if it's available.
if executable('fd')
	let s:files_fetcher = function('s:FdFiles')
endif

" Obtain fuzzy-matched list of filenames for the :find command.
function! s:FindFunc(file, _) abort
	if empty(s:filescache)
		let s:filescache = s:files_fetcher()
	endif
	return a:file == '' ? s:filescache : matchfuzzy(s:filescache, a:file)
endfunction

" Set findfunc but only if it's supported.
if exists('+findfunc')
	set findfunc=s:FindFunc
endif

" Set up Git TUI client
if executable('lazygit')
	function! Git()
		execute 'silent !lazygit'
		redraw!
	endfunction
	nmap <c-g> :call Git()<cr>
endif

function! s:FormatFile() abort
	if &formatprg==""
		return
	endif
	let l:view = winsaveview()
	keepjumps silent! normal! gggqG
	if v:shell_error
		silent undo
		echoerr printf(
					\ 'formatprg "%s" exited with status %d',
					\ &formatprg,
					\ v:shell_error
					\ )
	endif
	keepjumps call winrestview(l:view)
endfunction

augroup autoformat
	autocmd!
	autocmd BufWritePre * call <sid>FormatFile()
augroup END

augroup cmdline_autocomplete
	autocmd!
	" Trigger cmdline autocompletion
	if exists('*wildtrigger')
		autocmd CmdlineChanged [:\/\?] call wildtrigger()
	endif
	" Empty files cache on cmdline entry
	autocmd CmdlineEnter : let s:filescache = []
augroup END

" Enable built-in packages
silent! packadd comment
silent! packadd hlyank | let g:hlyank_duration = 150
silent! packadd nohlsearch
